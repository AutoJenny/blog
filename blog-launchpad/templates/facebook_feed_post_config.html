<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ platform.display_name }} {{ channel_type.display_name }} Configuration - Blog Launchpad</title>
    <!-- Tailwind CSS for header -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/launchpad.css') }}">
    <style>
        /* Channel config specific styles */
        .channel-header {
            background: linear-gradient(135deg, #1877f2 0%, #0d6efd 100%);
            color: white;
            padding: 2rem;
            border-radius: 16px;
            margin-bottom: 2rem;
        }
        
        .config-section {
            margin-bottom: 2rem;
        }
        
        .section-title {
            color: #e0e0e0;
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .config-card {
            background: linear-gradient(135deg, #1a1f2e 0%, #2d3748 100%);
            border: 1px solid #4a5568;
            border-radius: 12px;
            margin-bottom: 1rem;
        }
        
        .config-card.channel-specific {
            border-left: 6px solid #06b6d4;
        }
        
        .config-card.platform-wide {
            border-left: 6px solid #8b5cf6;
        }
        
        .card-header {
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid #4a5568;
            padding: 1rem 1.5rem;
            border-radius: 12px 12px 0 0;
        }
        
        .card-body {
            padding: 1.5rem;
        }
        
        .config-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid #4a5568;
        }
        
        .config-item:last-child {
            border-bottom: none;
        }
        
        .config-name {
            font-weight: 500;
            color: #e0e0e0;
        }
        
        .config-value {
            color: #a0aec0;
            font-family: monospace;
        }
        
        .config-description {
            color: #718096;
            font-size: 0.9rem;
            margin-top: 0.25rem;
        }
        
        /* Accordion Styles for Channel Requirements */
        .accordion-item.config-card {
            background: linear-gradient(135deg, #1a1f2e 0%, #2d3748 100%);
            border: 1px solid #4a5568;
            border-radius: 12px;
            margin-bottom: 1rem;
            overflow: hidden;
        }
        
        .accordion-button {
            background: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
            border: none;
            color: #e0e0e0;
            padding: 1.25rem;
            font-weight: 600;
            box-shadow: none;
        }
        
        .accordion-button:not(.collapsed) {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white;
            box-shadow: none;
        }
        
        .accordion-button:focus {
            box-shadow: 0 0 0 0.25rem rgba(6, 182, 212, 0.25);
            border-color: #06b6d4;
        }
        
        .accordion-button::after {
            display: none;
        }
        
        .requirement-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .requirement-indicator .badge {
            font-size: 0.8rem;
            padding: 0.5rem 0.75rem;
        }
        
        .requirement-indicator .fa-chevron-down {
            transition: transform 0.3s ease;
        }
        
        .accordion-collapse {
            background: linear-gradient(135deg, #1a1f2e 0%, #2d3748 100%);
        }
        
        .accordion-body {
            padding: 1.5rem;
            border-top: 1px solid #4a5568;
        }
        
        .requirements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }
        
        .requirement-category {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #4a5568;
            border-radius: 8px;
            padding: 1.5rem;
        }
        
        .category-title {
            color: #e0e0e0;
            font-weight: 600;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #4a5568;
        }
        
        .requirement-category .config-item {
            padding: 0.75rem 0;
            border-bottom: 1px solid #4a5568;
        }
        
        .requirement-category .config-item:last-child {
            border-bottom: none;
        }
        
        .breadcrumb-nav {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #4a5568;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 2rem;
        }
        
        .breadcrumb {
            display: flex;
            flex-wrap: wrap;
            padding: 0;
            margin: 0;
            list-style: none;
            background: transparent;
        }
        
        .breadcrumb-item {
            display: flex;
            align-items: center;
            color: #a0aec0;
        }
        
        .breadcrumb-item + .breadcrumb-item::before {
            content: ">";
            color: #6b7280;
            margin: 0 0.5rem;
        }
        
        .breadcrumb-item.active {
            color: #e0e0e0;
        }
        
        .breadcrumb-item a {
            color: #667eea;
            text-decoration: none;
        }
        
        .breadcrumb-item a:hover {
            color: #a5b4fc;
        }
        
        /* Accordion Styles for Blog Posts */
        .section-card {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 12px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #f1f5f9;
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            user-select: none;
            padding: 30px;
            margin: 0;
            transition: background-color 0.2s ease;
        }
        
        .section-title.with-right-content {
            justify-content: space-between;
        }
        
        .section-title-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .section-title-right {
            display: flex;
            align-items: center;
            text-align: right;
        }
        
        .section-title:hover {
            background-color: #334155;
        }
        
        .section-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
        }
        
        .section-content.expanded {
            max-height: 2000px;
            padding: 0 30px 30px 30px;
        }
        
        .accordion-chevron {
            transition: transform 0.3s ease;
        }
        
        .accordion-chevron.expanded {
            transform: rotate(90deg);
        }
        
        /* Header Styles */
        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        .status-active {
            background: #10b981;
            color: white;
        }
        
        .status-limited {
            background: #f59e0b;
            color: white;
        }
        
        .status-draft {
            background: #6b7280;
            color: white;
        }
        
        .priority-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 600;
        }
        
        .priority-high {
            background: #dc2626;
            color: white;
        }
        
        .priority-medium {
            background: #ea580c;
            color: white;
        }
        
        .priority-low {
            background: #16a34a;
            color: white;
        }
        
        /* Header styling overrides for this page */
        .header-gradient {
            background: linear-gradient(90deg, #181c2a 0%, #23273a 100%) !important;
            border-bottom: 1px solid #31364a !important;
        }
        
        .header-gradient .nav-link {
            color: #e0e0e0 !important;
        }
        
        .header-gradient .nav-link:hover {
            color: #ffffff !important;
        }
        
        .header-gradient .dropdown-menu {
            background: #23273a !important;
            border: 1px solid #31364a !important;
            box-shadow: 0 4px 24px 0 rgba(0, 0, 0, 0.45) !important;
        }
        
        .header-gradient .dropdown-item {
            color: #e0e0e0 !important;
        }
        
        .header-gradient .dropdown-item:hover {
            background: #31364a !important;
            color: #ffffff !important;
        }
        
        /* Ensure header is above other content */
        .header-gradient {
            position: relative;
            z-index: 1000;
        }
        
        /* Body styling to match daily product posts */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f172a;
            min-height: 100vh;
            color: #e0e0e0;
        }
        
        /* Container styling to match daily product posts */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Additional header-related classes */
        .nav-dropdown {
            background: #23273a;
            border: 1px solid #31364a;
            box-shadow: 0 4px 24px 0 rgba(0, 0, 0, 0.45);
        }
        .nav-dropdown a {
            color: #e0e0e0;
        }
        .nav-dropdown a:hover {
            background: #23273a;
            color: #a5b4fc;
        }
        .text-dark-text {
            color: #e0e0e0;
        }
        .text-dark-accent {
            color: #a5b4fc;
        }
        .hover\:text-dark-accent:hover {
            color: #a5b4fc;
        }
        .hover\:bg-dark-bg:hover {
            background: #23273a;
        }
        .bg-dark-accent {
            background: #a5b4fc;
        }
        .bg-dark-bg {
            background: #23273a;
        }
        
        /* Posting Control and Queue Styles */
        .status-indicator {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .status-ready {
            background: #10b981;
            color: white;
        }
        
        .status-posted {
            background: #3b82f6;
            color: white;
        }
        
        .status-draft {
            background: #f59e0b;
            color: white;
        }
        
        .content-type-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .content-type-btn {
            padding: 8px 16px;
            border: 1px solid #475569;
            background: #23273a;
            color: #94a3b8;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .content-type-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #1d4ed8;
        }
        
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #334155;
            border-top: 2px solid #10b981;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Queue Styles */
        .queue-item {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: move;
            transition: all 0.3s ease;
        }
        
        .queue-item:hover {
            border-color: #475569;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .queue-item-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            cursor: pointer;
        }
        
        .queue-item-thumbnail {
            width: 50px;
            height: 50px;
            border-radius: 6px;
            object-fit: cover;
            border: 1px solid #334155;
        }
        
        .queue-item-info {
            flex: 1;
        }
        
        .queue-item-title {
            font-weight: 600;
            color: #f1f5f9;
            margin-bottom: 4px;
        }
        
        .queue-item-sku {
            font-size: 0.85rem;
            color: #94a3b8;
        }
        
        .queue-item-actions {
            display: flex;
            gap: 8px;
        }
        
        .queue-item-delete {
            background: #ef4444;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            color: white;
            cursor: pointer;
            font-size: 0.8rem;
        }
        
        .queue-item-delete:hover {
            background: #dc2626;
        }
        
        .queue-item-content {
            padding: 0 15px 15px 15px;
            display: none;
        }
        
        .queue-item-content.expanded {
            display: block;
        }
        
        .queue-item-content-text {
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 6px;
            padding: 12px;
            color: #f1f5f9;
            font-size: 0.9rem;
            line-height: 1.5;
        }
        
        /* Queue Table Styles */
        .queue-table-row {
            border-bottom: 1px solid #334155;
        }
        
        .queue-table-row:last-child {
            border-bottom: none;
        }
        
        .schedule-cell {
            width: 200px;
            padding: 15px;
            vertical-align: top;
        }
        
        .schedule-time {
            font-size: 1.1rem;
            font-weight: 600;
            color: #f1f5f9;
            margin-bottom: 4px;
        }
        
        .schedule-date {
            font-size: 0.9rem;
            color: #94a3b8;
            margin-bottom: 4px;
        }
        
        .schedule-name {
            font-size: 0.8rem;
            color: #10b981;
            background: #064e3b;
            padding: 2px 8px;
            border-radius: 12px;
            display: inline-block;
        }
        
        .queue-items-cell {
            padding: 15px;
            vertical-align: top;
        }
        
        .queue-item-table {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: move;
            transition: all 0.3s ease;
        }
        
        .queue-item-table:hover {
            border-color: #475569;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .queue-item-table-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            cursor: pointer;
        }
        
        .queue-item-table-thumbnail {
            width: 50px;
            height: 50px;
            border-radius: 6px;
            object-fit: cover;
            border: 1px solid #334155;
        }
        
        .queue-item-table-info {
            flex: 1;
        }
        
        .queue-item-table-title {
            font-weight: 600;
            color: #f1f5f9;
            margin-bottom: 4px;
        }
        
        .queue-item-table-sku {
            font-size: 0.85rem;
            color: #94a3b8;
        }
        
        .queue-item-table-actions {
            display: flex;
            gap: 8px;
        }
        
        .queue-item-table-delete {
            background: #ef4444;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            color: white;
            cursor: pointer;
            font-size: 0.8rem;
        }
        
        .queue-item-table-delete:hover {
            background: #dc2626;
        }
        
        .queue-item-table-content {
            padding: 0 15px 15px 15px;
            display: none;
        }
        
        .queue-item-table-content.expanded {
            display: block;
        }
        
        .queue-item-table-content-text {
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 6px;
            padding: 12px;
            color: #f1f5f9;
            font-size: 0.9rem;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    {% include 'shared/header.html' %}
    
    <div class="container">
        <!-- Breadcrumb Navigation -->
        <div class="breadcrumb-nav">
            <nav aria-label="breadcrumb">
                <ol class="breadcrumb mb-0">
                    <li class="breadcrumb-item">
                        <a href="/"><i class="fas fa-home me-1"></i>Blog Forge</a>
                    </li>
                    <li class="breadcrumb-item">
                        <a href="/syndication/dashboard"><i class="fab fa-{{ platform.name|lower }} me-1"></i>{{ platform.display_name }}</a>
                    </li>
                    <li class="breadcrumb-item active" aria-current="page">
                        <i class="fas fa-newspaper me-1"></i>{{ channel_type.display_name }} Configuration
                    </li>
                </ol>
            </nav>
        </div>
        
        <!-- Page Header -->
        <div class="header">
            <h1>ðŸ“° Blog Posts</h1>
            <p>Automated Facebook posts featuring blog content and articles</p>
        </div>
        
        <!-- Blog Post Management Accordions -->
        <!-- Item Selection Section -->
        <div class="section-card">
            <div class="section-title" onclick="toggleAccordion('item-selection')">
                <i class="fas fa-chevron-right accordion-chevron" id="item-selection-chevron"></i>
                <i class="fas fa-newspaper"></i>
                Item Selection
            </div>
            <div class="section-content" id="item-selection-content">
                <!-- Post Selection -->
                <div class="mb-4">
                    <label for="postSelector" class="form-label text-white">Choose a published post:</label>
                    <select class="form-select bg-dark text-white border-secondary" id="postSelector">
                        <option value="">Loading posts...</option>
                    </select>
                </div>
                
                <!-- Selected Post Details -->
                <div id="postDetails" class="d-none">
                    <hr class="border-secondary">
                    <h6 class="text-info mb-3">Post Details</h6>
                    <div class="row">
                        <div class="col-md-6">
                            <p><strong>Title:</strong> <span id="postTitle"></span></p>
                            <p><strong>Created Date:</strong> <span id="postCreatedAt"></span></p>
                            <p><strong>Last Updated:</strong> <span id="postUpdatedAt"></span></p>
                        </div>
                        <div class="col-md-6">
                            <p><strong>Post ID:</strong> <span id="postId"></span></p>
                            <p><strong>Status:</strong> <span id="postStatus"></span></p>
                            <p><strong>Slug:</strong> <span id="postSlug"></span></p>
                            <p><strong>Number of Sections:</strong> <span id="postSectionCount"></span></p>
                        </div>
                    </div>
                </div>
                
                <!-- Post Sections List -->
                <div id="sectionsList" class="d-none">
                    <hr class="border-secondary">
                    <h6 class="text-info mb-3">Post Sections</h6>
                    <div id="sectionsContainer">
                        <!-- Section titles will be populated here -->
                    </div>
                    
                    <!-- Generate All Sections Button -->
                    <div class="mt-4 text-center">
                        <button id="generateAllSectionsBtn" class="btn btn-success btn-lg" disabled>
                            <i class="fas fa-magic me-2"></i>Generate all <span id="sectionCount">0</span> sections
                        </button>
                        <div id="generationProgress" class="mt-3 d-none">
                            <div class="progress mb-2">
                                <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated" 
                                     role="progressbar" style="width: 0%"></div>
                            </div>
                            <small class="text-muted" id="progressText">Preparing...</small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Content Generation Section -->
        <div class="section-card">
            <div class="section-title" onclick="toggleAccordion('content-generation')">
                <i class="fas fa-chevron-right accordion-chevron" id="content-generation-chevron"></i>
                <i class="fas fa-robot"></i>
                AI Content Generation
            </div>
            <div class="section-content" id="content-generation-content">
                <!-- Generated Content Results -->
                <div id="generatedContentResults" class="d-none">
                    <h6 class="text-info mb-3">
                        <i class="fas fa-check-circle me-2"></i>Generated Facebook Posts
                    </h6>
                    <div id="generatedPostsContainer">
                        <!-- Generated posts will be displayed here -->
                    </div>
                </div>
                
                <!-- Queue Display for Selected Post -->
                <div id="queueDisplay" class="d-none">
                    <h6 class="text-success mb-3">
                        <i class="fas fa-list me-2"></i>Queue Items for Selected Post
                    </h6>
                    <div id="queueItemsContainer">
                        <!-- Queue items will be displayed here -->
                    </div>
                </div>
                
                <!-- Placeholder when no post selected -->
                <div id="contentGenerationPlaceholder">
                    <div style="text-align: center; color: #94a3b8; padding: 40px 20px; font-style: italic;">
                        <i class="fas fa-robot" style="font-size: 2rem; margin-bottom: 10px; display: block;"></i>
                        Select a post and click "Generate all sections" to create Facebook posts from your blog content.
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Posting Control Section -->
        {% include 'includes/posting_control.html' %}
        
        <!-- Posting Queue Section -->
        {% include 'includes/posting_queue.html' %}
        
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        function toggleAccordion(sectionId) {
            const content = document.getElementById(sectionId + '-content');
            const chevron = document.getElementById(sectionId + '-chevron');
            
            if (content.classList.contains('expanded')) {
                // Collapse
                content.classList.remove('expanded');
                chevron.classList.remove('expanded');
            } else {
                // Expand
                content.classList.add('expanded');
                chevron.classList.add('expanded');
            }
        }

        // Manual Post Selection Functionality
        function loadPosts() {
            const postSelector = document.getElementById('postSelector');
            
            // Show loading state
            postSelector.innerHTML = '<option value="">Loading posts...</option>';
            
            // Get all published posts
            fetch('/api/syndication/posts')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.posts && data.posts.length > 0) {
                        postSelector.innerHTML = '<option value="">Select a post...</option>';
                        data.posts.forEach(post => {
                            const option = document.createElement('option');
                            option.value = post.id;
                            option.textContent = `${post.title} (ID: ${post.id})`;
                            postSelector.appendChild(option);
                        });
                    } else {
                        postSelector.innerHTML = '<option value="">No posts found</option>';
                    }
                })
                .catch(error => {
                    console.error('Error loading posts:', error);
                    postSelector.innerHTML = '<option value="">Error loading posts</option>';
                });
        }

        function loadPostSections(postId) {
            const sectionsContainer = document.getElementById('sectionsContainer');
            const sectionsList = document.getElementById('sectionsList');
            
            fetch(`/api/syndication/post-sections/${postId}`)
                .then(response => response.json())
                .then(data => {
                    sectionsContainer.innerHTML = '';
                    
                    if (data.sections && data.sections.length > 0) {
                        // Store sections globally for content generation
                        currentSections = data.sections;
                        currentPostId = postId;
                        
                        // Update section count and enable generate button
                        updateSectionCount(data.sections.length);
                        
                        data.sections.forEach(section => {
                            const sectionDiv = document.createElement('div');
                            sectionDiv.className = 'mb-2 p-2 bg-dark border border-secondary rounded';
                            sectionDiv.innerHTML = `
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        <strong class="text-white">Section ${section.order}: ${section.title || 'Untitled'}</strong>
                                        <small class="text-muted d-block">${section.content ? section.content.substring(0, 100) + '...' : 'No content'}</small>
                                    </div>
                                    <div>
                                        <span class="badge bg-info">${section.id}</span>
                                    </div>
                                </div>
                            `;
                            sectionsContainer.appendChild(sectionDiv);
                        });
                        sectionsList.classList.remove('d-none');
                    } else {
                        currentSections = [];
                        currentPostId = null;
                        updateSectionCount(0);
                        sectionsContainer.innerHTML = '<p class="text-muted">No sections found for this post.</p>';
                        sectionsList.classList.remove('d-none');
                    }
                })
                .catch(error => {
                    console.error('Error loading sections:', error);
                    currentSections = [];
                    currentPostId = null;
                    updateSectionCount(0);
                    sectionsContainer.innerHTML = '<p class="text-danger">Error loading sections</p>';
                    sectionsList.classList.remove('d-none');
                });
        }

        function updatePostDetails(post) {
            document.getElementById('postTitle').textContent = post.title;
            document.getElementById('postCreatedAt').textContent = new Date(post.created_at).toLocaleDateString();
            document.getElementById('postUpdatedAt').textContent = new Date(post.updated_at).toLocaleDateString();
            document.getElementById('postId').textContent = post.id;
            document.getElementById('postStatus').textContent = post.status;
            document.getElementById('postSlug').textContent = post.slug;
            document.getElementById('postSectionCount').textContent = post.section_count || 'Unknown';
            
            document.getElementById('postDetails').classList.remove('d-none');
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Load all posts for manual selection
            loadPosts();
            
            // Add event listener for post selection
            document.getElementById('postSelector').addEventListener('change', function() {
                const postId = this.value;
                if (postId) {
                    // Save selected post to localStorage
                    localStorage.setItem('selectedBlogPostId', postId);
                    currentPostId = parseInt(postId);
                    
                    loadPostSections(postId);
                    // Load post details
                    fetch(`/api/syndication/posts/${postId}`)
                        .then(response => response.json())
                        .then(data => {
                            if (data.status === 'success' && data.post) {
                                updatePostDetails(data.post);
                            }
                        })
                        .catch(error => {
                            console.error('Error loading post details:', error);
                        });
                    
                    // Display queue items for selected post
                    displayQueueForSelectedPost(postId);
                    // Also update the Posting Queue panel
                    renderQueue();
                } else {
                    // Clear saved post from localStorage
                    localStorage.removeItem('selectedBlogPostId');
                    currentPostId = null;
                    
                    document.getElementById('postDetails').classList.add('d-none');
                    document.getElementById('sectionsList').classList.add('d-none');
                    // Show placeholder when no post selected
                    displayQueueForSelectedPost(null);
                    // Also update the Posting Queue panel to show all items
                    renderQueue();
                }
            });
            
            // Add event listener for Generate All Sections button
            document.getElementById('generateAllSectionsBtn').addEventListener('click', function() {
                generateAllSections();
            });
        });
        
        // Content Generation Functions
        let currentSections = [];
        let currentPostId = null;
        
        function updateSectionCount(count) {
            document.getElementById('sectionCount').textContent = count;
            const generateBtn = document.getElementById('generateAllSectionsBtn');
            generateBtn.disabled = count === 0;
        }
        
        function showProgress(show = true) {
            const progressDiv = document.getElementById('generationProgress');
            if (show) {
                progressDiv.classList.remove('d-none');
            } else {
                progressDiv.classList.add('d-none');
            }
        }
        
        function updateProgress(percent, text) {
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }
        
        async function generateAllSections() {
            if (!currentPostId || currentSections.length === 0) {
                alert('Please select a post with sections first.');
                return;
            }
            
            const generateBtn = document.getElementById('generateAllSectionsBtn');
            const originalText = generateBtn.innerHTML;
            
            try {
                // Disable button and show progress
                generateBtn.disabled = true;
                generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Generating...';
                showProgress(true);
                
                let completedCount = 0;
                const totalCount = currentSections.length;
                const generatedPosts = [];
                
                // Process each section sequentially
                for (let i = 0; i < currentSections.length; i++) {
                    const section = currentSections[i];
                    
                    // Update progress
                    const percent = Math.round((completedCount / totalCount) * 100);
                    updateProgress(percent, `Processing section ${completedCount + 1}/${totalCount}: ${section.title}`);
                    
                    try {
                        // Generate content for this section
                        const generatedContent = await processSectionWithLLM(section, i);
                        generatedPosts.push({
                            sectionId: section.id,
                            sectionTitle: section.title,
                            content: generatedContent,
                            sectionIndex: i
                        });
                        
                        completedCount++;
                        
                        // Small delay between sections
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        
                    } catch (error) {
                        console.error(`Error processing section ${i + 1}:`, error);
                        // Continue with next section
                    }
                }
                
                // Update progress to completion
                updateProgress(100, `Saving to database...`);
                
                // Add generated posts to queue (saves to database)
                await addGeneratedPostsToQueue(generatedPosts);
                
                // Display from database (not from generatedPosts array)
                await displayQueueForSelectedPost(currentPostId);
                
                // Show success message
                setTimeout(() => {
                    showProgress(false);
                    alert(`Successfully generated ${completedCount} Facebook posts and saved them to the database!`);
                }, 1000);
                
            } catch (error) {
                console.error('Error generating content:', error);
                alert(`Error generating content: ${error.message}`);
                showProgress(false);
            } finally {
                // Restore button
                generateBtn.disabled = false;
                generateBtn.innerHTML = originalText;
            }
        }
        
        async function processSectionWithLLM(section, sectionIndex) {
            try {
                // Get LLM settings (using defaults for now)
                const llmRequest = {
                    provider: 'ollama',
                    model: 'mistral',
                    prompt: assembleLLMPrompt(section),
                    temperature: 0.7,
                    max_tokens: 1000
                };
                
                // Send to LLM service
                const response = await fetch('/api/syndication/ollama/direct', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(llmRequest)
                });
                
                const result = await response.json();
                
                if (result.error) {
                    throw new Error(result.error);
                }
                
                // Extract response content
                const responseContent = result.output || result.result || result.response || result.content || 'No response received';
                
                // Save to database
                await saveSyndicationPiece(section, responseContent, llmRequest, sectionIndex);
                
                return responseContent;
                
            } catch (error) {
                console.error('Error processing section with LLM:', error);
                throw error;
            }
        }
        
        function assembleLLMPrompt(section) {
            const systemPrompt = 'You are a social media content specialist. Write a Facebook feed post based on the blog section below.';
            const userPrompt = `RULES:
. Output ONLY the final post text â€” no explanations, no notes, no commentary, no placeholders, no brackets.
. Use a conversational, engaging, and authentic tone.
. Include a clear call-to-action.
. Avoid the word 'delve'.
. Use EXACTLY THREE relevant hashtags, placed ONLY at the very end.
. Post length must be 150â€“200 characters.`;
            
            // Get blog post title
            const postTitle = document.getElementById('postTitle').textContent || 'Blog Post';
            
            // Clean section content
            let sectionText = section.content || section.polished || 'No content available';
            sectionText = sectionText
                .replace(/#\d+/g, '') // Remove post numbers like #53
                .replace(/<[^>]*>/g, '') // Remove HTML tags
                .replace(/\s+/g, ' ') // Normalize whitespace
                .trim();
            
            // Build the blog details section
            const blogDetails = `Title: ${postTitle}\nSection: ${section.title}\nText: ${sectionText}`;
            
            // Assemble the final prompt
            const finalPrompt = `${systemPrompt}\n\n${userPrompt}\n\n=== BLOG DETAILS ===\n${blogDetails}\n\nNow write the final Facebook post`;
            
            return finalPrompt;
        }
        
        async function saveSyndicationPiece(section, generatedContent, llmRequest, sectionIndex) {
            try {
                const pieceData = {
                    post_id: currentPostId,
                    section_id: section.id,
                    platform_id: 1, // Facebook
                    channel_type_id: 1, // feed_post
                    process_id: 1, // Default process
                    original_content: JSON.stringify({
                        title: section.title,
                        content: section.content,
                        polished: section.polished
                    }),
                    generated_content: generatedContent,
                    llm_model: llmRequest.model,
                    llm_temperature: llmRequest.temperature,
                    llm_max_tokens: llmRequest.max_tokens,
                    llm_provider: llmRequest.provider,
                    prompt_used: llmRequest.prompt,
                    processing_time_ms: 0, // Will be calculated if needed
                    platform_name: 'Facebook',
                    channel_type_name: 'feed_post',
                    requirements: 'Facebook feed post requirements'
                };
                
                const response = await fetch('/api/syndication/pieces', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(pieceData)
                });
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    console.log('Syndication piece saved successfully:', result);
                } else {
                    console.error('Failed to save syndication piece:', result.error);
                }
                
            } catch (error) {
                console.error('Error saving syndication piece:', error);
            }
        }
        
        function displayGeneratedPosts(generatedPosts) {
            const resultsDiv = document.getElementById('generatedContentResults');
            const placeholderDiv = document.getElementById('contentGenerationPlaceholder');
            const container = document.getElementById('generatedPostsContainer');
            
            // Hide placeholder and show results
            placeholderDiv.classList.add('d-none');
            resultsDiv.classList.remove('d-none');
            
            // Clear previous results
            container.innerHTML = '';
            
            // Display each generated post
            generatedPosts.forEach((post, index) => {
                const postElement = document.createElement('div');
                postElement.className = 'generated-post mb-4 p-3 bg-dark border border-secondary rounded';
                postElement.innerHTML = `
                    <div class="d-flex justify-content-between align-items-start mb-2">
                        <h6 class="text-info mb-0">Section ${post.sectionIndex + 1}: ${post.sectionTitle}</h6>
                        <span class="badge bg-success">Generated</span>
                    </div>
                    <div class="generated-content p-3 bg-secondary rounded">
                        <p class="mb-0 text-white">${post.content}</p>
                    </div>
                    <div class="mt-2">
                        <small class="text-muted">
                            <i class="fas fa-clock me-1"></i>Generated: ${new Date().toLocaleTimeString()}
                        </small>
                    </div>
                `;
                container.appendChild(postElement);
            });
            
            // Auto-expand the AI Content Generation accordion
            const accordionContent = document.getElementById('content-generation-content');
            const chevron = document.getElementById('content-generation-chevron');
            if (accordionContent && chevron) {
                accordionContent.style.display = 'block';
                chevron.classList.remove('fa-chevron-right');
                chevron.classList.add('fa-chevron-down');
            }
        }
        
        // Clean function to display queue items for selected post
        async function displayQueueForSelectedPost(postId) {
            if (!postId) {
                // No post selected, show placeholder
                document.getElementById('contentGenerationPlaceholder').classList.remove('d-none');
                document.getElementById('queueDisplay').classList.add('d-none');
                document.getElementById('generatedContentResults').classList.add('d-none');
                return;
            }
            
            try {
                // Fetch queue items for this specific post
                const response = await fetch(`/api/queue?content_type=blog_post&platform=facebook&channel_type=feed_post&post_id=${postId}`);
                const data = await response.json();
                
                if (data.success && data.items && data.items.length > 0) {
                    // Show queue items
                    document.getElementById('contentGenerationPlaceholder').classList.add('d-none');
                    document.getElementById('generatedContentResults').classList.add('d-none');
                    document.getElementById('queueDisplay').classList.remove('d-none');
                    
                    // Display queue items
                    const container = document.getElementById('queueItemsContainer');
                    container.innerHTML = '';
                    
                    data.items.forEach((item, index) => {
                        const itemElement = document.createElement('div');
                        itemElement.className = 'queue-item mb-3 p-3 bg-dark border border-secondary rounded';
                        itemElement.innerHTML = `
                            <div class="d-flex justify-content-between align-items-start mb-2">
                                <h6 class="text-success mb-0">${item.section_title}</h6>
                                <span class="badge bg-primary">${item.status}</span>
                            </div>
                            <div class="queue-content p-3 bg-secondary rounded mb-2">
                                <p class="mb-0 text-white">${item.generated_content}</p>
                            </div>
                            <div class="d-flex justify-content-between align-items-center">
                                <small class="text-muted">
                                    <i class="fas fa-calendar me-1"></i>${item.scheduled_date} at ${item.scheduled_time}
                                </small>
                                <small class="text-muted">
                                    <i class="fas fa-clock me-1"></i>Queue Order: ${item.queue_order}
                                </small>
                            </div>
                        `;
                        container.appendChild(itemElement);
                    });
                } else {
                    // No queue items for this post, show placeholder
                    document.getElementById('contentGenerationPlaceholder').classList.remove('d-none');
                    document.getElementById('queueDisplay').classList.add('d-none');
                    document.getElementById('generatedContentResults').classList.add('d-none');
                }
            } catch (error) {
                console.error('Error loading queue for post:', error);
                // Show placeholder on error
                document.getElementById('contentGenerationPlaceholder').classList.remove('d-none');
                document.getElementById('queueDisplay').classList.add('d-none');
                document.getElementById('generatedContentResults').classList.add('d-none');
            }
        }
        
        async function addGeneratedPostsToQueue(generatedPosts) {
            try {
                console.log('Adding generated posts to queue...');
                
                // Get current blog post schedules to calculate posting times
                const scheduleResponse = await fetch('/api/schedules?content_type=blog_post&platform=facebook&channel_type=feed_post');
                const scheduleData = await scheduleResponse.json();
                
                let schedules = [];
                if (scheduleData.success) {
                    schedules = scheduleData.schedules || [];
                }
                
                // Generate sequential posting times
                const postingTimes = generateSequentialTimes(generatedPosts.length, schedules);
                
                // Add each generated post to the queue using unified API
                for (let i = 0; i < generatedPosts.length; i++) {
                    const post = generatedPosts[i];
                    const postingTime = postingTimes[i];
                    
                    const queueData = {
                        platform: 'facebook',
                        channel_type: 'feed_post',
                        content_type: 'blog_post',
                        product_id: currentPostId,  // product_id stores post_id for blog posts
                        section_id: post.sectionId,
                        generated_content: post.content,
                        scheduled_date: postingTime.date.toISOString().split('T')[0],
                        scheduled_time: postingTime.schedule.time,
                        schedule_name: postingTime.schedule.name,
                        timezone: postingTime.schedule.timezone,
                        status: 'ready'
                    };
                    
                    const response = await fetch('/api/queue', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(queueData)
                    });
                    
                    const result = await response.json();
                    
                    if (!result.success) {
                        console.error(`Failed to add section ${i + 1} to queue:`, result.error);
                    }
                }
                
                // Reload the queue to show the new items
                await loadQueueData();
                
                console.log('Successfully added generated posts to queue');
                
            } catch (error) {
                console.error('Error adding generated posts to queue:', error);
            }
        }
        
        // Posting Control and Queue Management Functions
        let queueData = [];
        let scheduleData = [];
        let draggedItem = null;
        
        // DOM elements for posting control and queue
        const clearQueueBtn = document.getElementById('clear-queue-btn');
        const queueCount = document.getElementById('queue-count');
        const emptyQueue = document.getElementById('empty-queue');
        const queueTableContainer = document.getElementById('queue-table-container');
        const queueTableBody = document.getElementById('queue-table-body');
        
        // Initialize posting control and queue functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Load all posts for manual selection
            loadPosts();
            
            // Load schedule and queue data in coordinated manner
            loadQueueData();
            loadScheduleData();
            
            // Add event listeners for posting control
            initializePostingControl();
            
            // Add event listeners for queue management
            initializeQueueManagement();
            
            // Restore previously selected post from localStorage AFTER data is loaded
            const savedPostId = localStorage.getItem('selectedBlogPostId');
            if (savedPostId) {
                // Set the selector value and trigger the change event
                const postSelector = document.getElementById('postSelector');
                postSelector.value = savedPostId;
                currentPostId = parseInt(savedPostId);
                
                // Load sections and details for the saved post
                loadPostSections(savedPostId);
                fetch(`/api/syndication/posts/${savedPostId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'success' && data.post) {
                            updatePostDetails(data.post);
                        }
                    })
                    .catch(error => {
                        console.error('Error loading post details:', error);
                    });
                
                // Display queue items for restored post
                displayQueueForSelectedPost(savedPostId);
                // Also update the Posting Queue panel
                renderQueue();
            }
        });
        
        // Initialize posting control functionality
        function initializePostingControl() {
            // Add schedule form handlers
            const addScheduleBtn = document.getElementById('add-schedule-btn');
            const addScheduleForm = document.getElementById('add-schedule-form');
            const saveNewScheduleBtn = document.getElementById('save-new-schedule-btn');
            const cancelNewScheduleBtn = document.getElementById('cancel-new-schedule-btn');
            
            if (addScheduleBtn) {
                addScheduleBtn.addEventListener('click', () => {
                    addScheduleForm.style.display = 'block';
                });
            }
            
            if (cancelNewScheduleBtn) {
                cancelNewScheduleBtn.addEventListener('click', () => {
                    addScheduleForm.style.display = 'none';
                });
            }
            
            if (saveNewScheduleBtn) {
                saveNewScheduleBtn.addEventListener('click', saveNewSchedule);
            }
            
            // Preset button handlers
            const presetWeekdays = document.getElementById('new-preset-weekdays');
            const presetWeekends = document.getElementById('new-preset-weekends');
            const presetEveryday = document.getElementById('new-preset-everyday');
            
            if (presetWeekdays) {
                presetWeekdays.addEventListener('click', () => setPresetDays([1,2,3,4,5]));
            }
            if (presetWeekends) {
                presetWeekends.addEventListener('click', () => setPresetDays([6,7]));
            }
            if (presetEveryday) {
                presetEveryday.addEventListener('click', () => setPresetDays([1,2,3,4,5,6,7]));
            }
            
            // Global schedule controls
            const testAllSchedulesBtn = document.getElementById('test-all-schedules-btn');
            const clearAllSchedulesBtn = document.getElementById('clear-all-schedules-btn');
            
            if (testAllSchedulesBtn) {
                testAllSchedulesBtn.addEventListener('click', testAllSchedules);
            }
            if (clearAllSchedulesBtn) {
                clearAllSchedulesBtn.addEventListener('click', clearAllSchedules);
            }
            
            // Manual controls
            const postNowBtn = document.getElementById('post-now-btn');
            const scheduleTomorrowBtn = document.getElementById('schedule-tomorrow-btn');
            
            if (postNowBtn) {
                postNowBtn.addEventListener('click', postNow);
            }
            if (scheduleTomorrowBtn) {
                scheduleTomorrowBtn.addEventListener('click', scheduleTomorrow);
            }
        }
        
        // Initialize queue management functionality
        function initializeQueueManagement() {
            // Add 10 items button handler
            const add10ItemsBtn = document.getElementById('add-10-items-btn');
            if (add10ItemsBtn) {
                add10ItemsBtn.addEventListener('click', add10Items);
            }
            
            // Clear queue button handler
            if (clearQueueBtn) {
                clearQueueBtn.addEventListener('click', clearQueue);
            }
        }
        
        // Load schedule data for blog posts
        async function loadScheduleData() {
            try {
                const response = await fetch('/api/schedules?content_type=blog_post&platform=facebook&channel_type=feed_post');
                const data = await response.json();
                
                if (data.success) {
                    scheduleData = data.schedules || [];
                    displaySchedules(scheduleData);
                    updateScheduleSummary(scheduleData);
                } else {
                    console.log('No blog post schedules found, using empty array');
                    scheduleData = [];
                    displaySchedules([]);
                    updateScheduleSummary([]);
                }
                
                // Now render the queue since schedules are loaded
                renderQueue();
            } catch (error) {
                console.error('Error loading blog post schedules:', error);
                scheduleData = [];
                displaySchedules([]);
                updateScheduleSummary([]);
                // Still render queue even if schedules failed to load
                renderQueue();
            }
        }
        
        // Load queue data from database
        async function loadQueueData() {
            try {
                console.log('Loading blog post queue data...');
                const response = await fetch('/api/queue?content_type=blog_post&platform=facebook&channel_type=feed_post');
                const data = await response.json();
                
                console.log('Blog post queue API response:', data);
                
                if (data.success) {
                    console.log('Queue API success, mapping items...');
                    console.log('Raw items:', data.items);
                    queueData = data.items.map(item => ({
                        id: item.id,
                        post: {
                            id: item.post_id,
                            title: item.post_title,
                            slug: item.post_slug,
                            created_at: item.post_created_at
                        },
                        section: {
                            title: item.section_title,
                            order: item.section_order
                        },
                        content: item.generated_content,
                        scheduled: {
                            date: item.scheduled_date,
                            time: item.scheduled_time,
                            schedule_name: item.schedule_name,
                            timezone: item.timezone
                        },
                        status: item.status,
                        queue_order: item.queue_order
                    }));
                    
                    console.log('Transformed blog post queue data:', queueData);
                    console.log('Queue data length:', queueData.length);
                    // Don't call renderQueue() here - it will be called after schedules are loaded
                } else {
                    console.error('Error loading blog post queue:', data.error);
                }
            } catch (error) {
                console.error('Error loading blog post queue:', error);
            }
        }
        
        // Display schedules
        function displaySchedules(schedules) {
            const schedulesList = document.getElementById('schedules-list');
            
            if (schedules.length === 0) {
                schedulesList.innerHTML = '<div style="color: #94a3b8; font-style: italic; text-align: center; padding: 20px;">No schedules configured</div>';
                return;
            }
            
            let html = '';
            schedules.forEach(schedule => {
                const pattern = formatSchedulePattern(schedule.days, schedule.time, schedule.timezone);
                const nextPost = calculateNextPostTime(schedule.days, schedule.time, schedule.timezone);
                
                html += `
                    <div style="background: #1e293b; border: 1px solid #334155; border-radius: 6px; padding: 15px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex: 1;">
                            <div style="color: #f1f5f9; font-weight: 600; margin-bottom: 5px;">${schedule.name}</div>
                            <div style="color: #94a3b8; font-size: 0.9rem; margin-bottom: 3px;">${pattern}</div>
                            <div style="color: #10b981; font-size: 0.85rem;">Next: ${nextPost}</div>
                        </div>
                        <button onclick="handleDeleteSchedule(${schedule.id})" 
                                style="background: #ef4444; border: none; border-radius: 4px; padding: 6px 10px; color: white; cursor: pointer; font-size: 0.8rem;">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                `;
            });
            
            schedulesList.innerHTML = html;
        }
        
        // Update schedule summary
        function updateScheduleSummary(schedules) {
            const nextPostsInfo = document.getElementById('next-posts-info');
            
            if (schedules.length === 0) {
                nextPostsInfo.textContent = 'No schedules active';
                return;
            }
            
            // Calculate next posts for all schedules
            const nextPosts = schedules.map(schedule => {
                const nextPost = calculateNextPostTime(schedule.days, schedule.time, schedule.timezone);
                return `${schedule.name}: ${nextPost}`;
            });
            
            nextPostsInfo.innerHTML = nextPosts.join('<br>');
        }
        
        // Render queue as table
        function renderQueue() {
            console.log('renderQueue called with queueData length:', queueData.length);
            console.log('queueData:', queueData);
            
            // Hide the placeholder when rendering queue
            const placeholderDiv = document.getElementById('contentGenerationPlaceholder');
            if (placeholderDiv) {
                placeholderDiv.classList.add('d-none');
            }
            
            // Generate sequential posting times (will be updated after filtering)
            let postingTimes = generateSequentialTimes(queueData.length);
            
            let html = '';
            let filteredItems = queueData;
            
            // Filter items to only show those for the currently selected post
            // If no post is selected, show all items; if a post is selected, show only that post's items
            if (currentPostId) {
                filteredItems = queueData.filter(item => item.post.id === parseInt(currentPostId));
                console.log(`Filtering queue for post ID ${currentPostId}, found ${filteredItems.length} items out of ${queueData.length} total`);
            } else {
                // When no post is selected, show all items (for initial page load)
                filteredItems = queueData;
                console.log(`No post selected, showing all ${queueData.length} items`);
            }
            
            // Update count to reflect filtered items
            queueCount.textContent = filteredItems.length;
            
            if (filteredItems.length === 0) {
                emptyQueue.style.display = 'block';
                queueTableContainer.style.display = 'none';
                clearQueueBtn.style.display = 'none';
                return;
            }
            
            // Regenerate posting times for filtered items
            postingTimes = generateSequentialTimes(filteredItems.length);
            
            filteredItems.forEach((item, index) => {
                const postingTime = postingTimes[index];
                
                // Fallback if postingTime is undefined
                if (!postingTime) {
                    console.error(`No posting time available for item ${index}`);
                    return; // Skip this item
                }
                
                const dateStr = postingTime.date.toLocaleDateString();
                const timeStr = postingTime.date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                
                html += `
                    <tr class="queue-table-row" data-row-index="${index}">
                        <td class="schedule-cell">
                            <div class="schedule-time">${timeStr}</div>
                            <div class="schedule-date">${dateStr}</div>
                            <div class="schedule-name">${postingTime.schedule.name}</div>
                        </td>
                        <td class="queue-items-cell">
                            <div class="queue-item-table" data-item-id="${item.id}" draggable="true">
                                <div class="queue-item-table-header" onclick="toggleQueueItemTable(${item.id})">
                                    <div class="queue-item-table-thumbnail" style="background: #3b82f6; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 1.2rem;">
                                        ðŸ“
                                    </div>
                                    <div class="queue-item-table-info">
                                        <div class="queue-item-table-title">${item.post.title}</div>
                                        <div class="queue-item-table-sku">Section ${item.section.order}: ${item.section.title}</div>
                                        <div class="queue-item-table-status" style="font-size: 0.8rem; color: #10b981; margin-top: 2px;">
                                            Status: ${item.status || 'ready'}
                                        </div>
                                    </div>
                                    <div class="queue-item-table-actions">
                                        <button class="queue-item-table-delete" onclick="event.stopPropagation(); removeFromQueue(${item.id})">
                                            <i class="fas fa-trash"></i>
                                        </button>
                                    </div>
                                </div>
                                <div class="queue-item-table-content" id="content-table-${item.id}">
                                    <div class="queue-item-table-content-text">${item.content}</div>
                                </div>
                            </div>
                        </td>
                    </tr>
                `;
            });
            
            queueTableBody.innerHTML = html;
            
            // Add drag and drop listeners
            addDragAndDropListeners();
        }
        
        // Generate sequential posting times
        function generateSequentialTimes(count, schedules = null) {
            const times = [];
            const now = new Date();
            const schedulesToUse = schedules || scheduleData;
            
            // Generate next 90 days of posting opportunities
            const allSlots = [];
            for (let i = 0; i < 90; i++) {
                const date = new Date(now);
                date.setDate(now.getDate() + i);
                const dayOfWeek = date.getDay() || 7; // Convert Sunday (0) to 7
                
                // Find schedules for this day
                const daySchedules = schedulesToUse.filter(schedule => {
                    const days = schedule.days || [];
                    return days.includes(dayOfWeek);
                });
                
                daySchedules.forEach(schedule => {
                    const slotDate = new Date(date);
                    const [hours, minutes] = schedule.time.split(':');
                    slotDate.setHours(parseInt(hours), parseInt(minutes), 0, 0);
                    
                    allSlots.push({
                        date: slotDate,
                        schedule: schedule
                    });
                });
            }
            
            // Sort by date/time and take first 'count' slots
            allSlots.sort((a, b) => a.date - b.date);
            
            // If we don't have enough slots, create additional ones
            while (allSlots.length < count) {
                const lastSlot = allSlots[allSlots.length - 1];
                const newDate = new Date(lastSlot.date);
                newDate.setHours(newDate.getHours() + 1); // Add 1 hour to the last slot
                
                allSlots.push({
                    date: newDate,
                    schedule: lastSlot.schedule
                });
            }
            
            return allSlots.slice(0, count);
        }
        
        // Helper functions for schedule management
        function formatSchedulePattern(days, time, timezone) {
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const selectedDays = days.map(d => dayNames[d - 1]).join(', ');
            return `${selectedDays} at ${time} ${timezone}`;
        }
        
        function calculateNextPostTime(days, time, timezone) {
            const now = new Date();
            const [hours, minutes] = time.split(':');
            
            // Find next occurrence
            for (let i = 0; i < 7; i++) {
                const checkDate = new Date(now);
                checkDate.setDate(now.getDate() + i);
                const dayOfWeek = checkDate.getDay() || 7;
                
                if (days.includes(dayOfWeek)) {
                    checkDate.setHours(parseInt(hours), parseInt(minutes), 0, 0);
                    if (checkDate > now) {
                        return checkDate.toLocaleString();
                    }
                }
            }
            
            return 'No upcoming posts';
        }
        
        // Helper function to get selected days
        function getSelectedDays() {
            const dayMap = {
                'new-day-mon': 1,
                'new-day-tue': 2,
                'new-day-wed': 3,
                'new-day-thu': 4,
                'new-day-fri': 5,
                'new-day-sat': 6,
                'new-day-sun': 7
            };
            
            const selectedDays = [];
            for (const [checkboxId, dayNumber] of Object.entries(dayMap)) {
                if (document.getElementById(checkboxId).checked) {
                    selectedDays.push(dayNumber);
                }
            }
            return selectedDays;
        }
        
        // Schedule management functions for blog posts
        async function saveNewSchedule() {
            const scheduleData = {
                name: document.getElementById('new-schedule-name').value,
                days: getSelectedDays(),
                time: document.getElementById('new-schedule-time').value,
                timezone: document.getElementById('new-schedule-timezone').value
            };
            
            try {
                // Add required fields for unified API
                const unifiedScheduleData = {
                    ...scheduleData,
                    platform: 'facebook',
                    channel_type: 'feed_post',
                    content_type: 'blog_post'
                };
                
                const response = await fetch('/api/schedules', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(unifiedScheduleData)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Hide form and clear fields
                    const addScheduleForm = document.getElementById('add-schedule-form');
                    if (addScheduleForm) {
                        addScheduleForm.style.display = 'none';
                        // Clear form fields manually
                        document.getElementById('new-schedule-name').value = '';
                        document.getElementById('new-schedule-time').value = '17:00';
                        document.getElementById('new-schedule-timezone').value = 'GMT';
                        // Clear day checkboxes (set to weekdays default)
                        const dayCheckboxes = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
                        dayCheckboxes.forEach((day, index) => {
                            const checkbox = document.getElementById(`new-day-${day}`);
                            if (checkbox) {
                                checkbox.checked = index < 5; // Weekdays checked by default
                            }
                        });
                    }
                    await loadScheduleData();
                    alert('Schedule created successfully!');
                } else {
                    alert('Error creating schedule: ' + result.error);
                }
            } catch (error) {
                console.error('Error creating schedule:', error);
                alert('Error creating schedule. Please try again.');
            }
        }
        
        function setPresetDays(days) {
            // Set checkboxes for specified days
            const dayCheckboxes = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
            dayCheckboxes.forEach((day, index) => {
                const checkbox = document.getElementById(`new-day-${day}`);
                if (checkbox) {
                    checkbox.checked = days.includes(index + 1);
                }
            });
        }
        
        async function testAllSchedules() {
            if (scheduleData.length === 0) {
                alert('No schedules to test');
                return;
            }
            
            alert(`Testing ${scheduleData.length} blog post schedules...`);
            // TODO: Implement actual schedule testing
        }
        
        async function clearAllSchedules() {
            if (confirm('Delete all blog post schedules?')) {
                try {
                    // Delete each schedule
                    for (const schedule of scheduleData) {
                        await fetch(`/api/schedules/${schedule.id}`, {
                            method: 'DELETE'
                        });
                    }
                    
                    await loadScheduleData();
                    alert('All schedules deleted successfully!');
                } catch (error) {
                    console.error('Error deleting schedules:', error);
                    alert('Error deleting schedules. Please try again.');
                }
            }
        }
        
        async function postNow() {
            if (queueData.length === 0) {
                alert('No items in queue to post');
                return;
            }
            
            // Find the first ready item
            const readyItem = queueData.find(item => item.status === 'ready');
            if (!readyItem) {
                alert('No ready items in queue to post');
                return;
            }
            
            if (confirm(`Post "${readyItem.post.title}" - Section ${readyItem.section.order}: ${readyItem.section.title}?`)) {
                try {
                    // Update status to processing
                    const updateResponse = await fetch(`/api/syndication/facebook/queue/${readyItem.id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ status: 'processing' })
                    });
                    
                    if (!updateResponse.ok) {
                        throw new Error('Failed to update item status');
                    }
                    
                    // Post to Facebook (using existing Facebook posting logic)
                    const postResponse = await fetch('/api/syndication/facebook/post', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            content: readyItem.content,
                            post_id: readyItem.id
                        })
                    });
                    
                    const postResult = await postResponse.json();
                    
                    if (postResult.success) {
                        // Update status to posted
                        await fetch(`/api/syndication/facebook/queue/${readyItem.id}`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ 
                                status: 'posted',
                                platform_post_id: postResult.post_id || 'posted'
                            })
                        });
                        
                        // Reload queue
                        await loadQueueData();
                        
                        alert('Successfully posted to Facebook!');
                    } else {
                        // Update status to failed
                        await fetch(`/api/syndication/facebook/queue/${readyItem.id}`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ 
                                status: 'failed',
                                error_message: postResult.error || 'Unknown error'
                            })
                        });
                        
                        // Reload queue
                        await loadQueueData();
                        
                        alert(`Failed to post: ${postResult.error || 'Unknown error'}`);
                    }
                    
                } catch (error) {
                    console.error('Error posting to Facebook:', error);
                    alert(`Error posting to Facebook: ${error.message}`);
                }
            }
        }
        
        async function scheduleTomorrow() {
            if (queueData.length === 0) {
                alert('No items in queue to schedule');
                return;
            }
            
            // Find the first ready item
            const readyItem = queueData.find(item => item.status === 'ready');
            if (!readyItem) {
                alert('No ready items in queue to schedule');
                return;
            }
            
            // Schedule for tomorrow at 9 AM
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setHours(9, 0, 0, 0);
            
            const scheduledDate = tomorrow.toISOString().split('T')[0];
            const scheduledTime = '09:00';
            
            try {
                const response = await fetch(`/api/syndication/facebook/queue/${readyItem.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        scheduled_date: scheduledDate,
                        scheduled_time: scheduledTime,
                        schedule_name: 'Tomorrow 9 AM',
                        timezone: 'GMT'
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    await loadQueueData();
                    alert(`Scheduled "${readyItem.post.title}" for tomorrow at 9:00 AM GMT`);
                } else {
                    alert('Error scheduling item: ' + result.error);
                }
            } catch (error) {
                console.error('Error scheduling item:', error);
                alert('Error scheduling item. Please try again.');
            }
        }
        
        async function handleDeleteSchedule(scheduleId) {
            if (confirm('Delete this schedule?')) {
            try {
                const response = await fetch(`/api/schedules/${scheduleId}`, {
                    method: 'DELETE'
                });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        await loadScheduleData();
                        alert('Schedule deleted successfully!');
                    } else {
                        alert('Error deleting schedule: ' + result.error);
                    }
                } catch (error) {
                    console.error('Error deleting schedule:', error);
                    alert('Error deleting schedule. Please try again.');
                }
            }
        }
        
        // Queue management functions
        async function add10Items() {
            if (confirm('Generate 10 new blog post items for the queue? This may take a few minutes.')) {
                const add10ItemsBtn = document.getElementById('add-10-items-btn');
                add10ItemsBtn.classList.add('loading');
                add10ItemsBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';
                add10ItemsBtn.disabled = true;
                
                try {
                    // Generate blog post content using the existing generation logic
                    // For now, we'll generate content for the currently selected post
                    if (!currentPostId || !currentSections || currentSections.length === 0) {
                        alert('Please select a post and generate content first before adding items to queue.');
                        return;
                    }
                    
                    // Generate content for all sections
                    const generatedPosts = [];
                    for (let i = 0; i < Math.min(10, currentSections.length); i++) {
                        const section = currentSections[i];
                        try {
                            const generatedContent = await processSectionWithLLM(section, i);
                            generatedPosts.push({
                                sectionId: section.id,
                                content: generatedContent,
                                sectionTitle: section.section_heading
                            });
                        } catch (error) {
                            console.error(`Error generating content for section ${i + 1}:`, error);
                        }
                    }
                    
                    // Add generated posts to queue
                    await addGeneratedPostsToQueue(generatedPosts);
                    
                    alert(`Successfully generated ${generatedPosts.length} blog post items for the queue!`);
                } catch (error) {
                    console.error('Error generating blog post items:', error);
                    alert('Error generating items: ' + error.message);
                } finally {
                    add10ItemsBtn.classList.remove('loading');
                    add10ItemsBtn.innerHTML = '<i class="fas fa-plus-circle"></i> Add 10 Items';
                    add10ItemsBtn.disabled = false;
                }
            }
        }
        
        async function clearQueue() {
            if (confirm('Clear all blog post items from queue?')) {
                try {
                    const response = await fetch('/api/queue/clear?content_type=blog_post&platform=facebook&channel_type=feed_post', {
                        method: 'DELETE'
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        queueData = [];
                        renderQueue();
                        alert('Queue cleared successfully!');
                    } else {
                        alert('Error clearing queue: ' + data.error);
                    }
                } catch (error) {
                    console.error('Error clearing queue:', error);
                    alert('Error clearing queue. Please try again.');
                }
            }
        }
        
        function toggleQueueItemTable(itemId) {
            const content = document.getElementById(`content-table-${itemId}`);
            if (content) {
                content.classList.toggle('expanded');
            }
        }
        
        async function removeFromQueue(itemId) {
            try {
                const response = await fetch(`/api/syndication/facebook/queue/${itemId}`, {
                    method: 'DELETE'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Remove from local data
                    queueData = queueData.filter(item => item.id !== itemId);
                    renderQueue();
                } else {
                    alert('Error removing from queue: ' + data.error);
                }
            } catch (error) {
                console.error('Error removing from queue:', error);
                alert('Error removing from queue. Please try again.');
            }
        }
        
        function addDragAndDropListeners() {
            const queueItems = document.querySelectorAll('.queue-item-table');
            
            queueItems.forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragend', handleDragEnd);
            });
            
            const tableRows = document.querySelectorAll('.queue-table-row');
            
            tableRows.forEach(row => {
                const cell = row.querySelector('.queue-items-cell');
                cell.addEventListener('dragover', handleDragOver);
                cell.addEventListener('dragleave', handleDragLeave);
                cell.addEventListener('drop', handleDrop);
            });
        }
        
        function handleDragStart(e) {
            draggedItem = e.target;
            e.target.style.opacity = '0.5';
        }
        
        function handleDragEnd(e) {
            e.target.style.opacity = '1';
            draggedItem = null;
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.style.backgroundColor = '#334155';
        }
        
        function handleDragLeave(e) {
            e.currentTarget.style.backgroundColor = '';
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.style.backgroundColor = '';
            
            if (draggedItem && e.currentTarget !== draggedItem.parentNode) {
                e.currentTarget.appendChild(draggedItem);
                updateQueueOrder();
            }
        }
        
        function updateQueueOrder() {
            console.log('Update queue order - to be implemented');
        }
    </script>
</body>
</html>
